// Prevent multiple executions
if (typeof window.itemsLoaded === 'undefined') {
    window.itemsLoaded = true;
    
    const backpackSkins = [

"10% attack juice",
"10% juice",
"10% power juice",
"10% protection juice",
"20% attack juice",
"20% juice",
"20% power juice",
"20% protection juice",
"25% attack juice",
"25% juice",
"25% power juice",
"25% protection juice",
"a grand ticket",
"alcohlic beverage cheetah",
"alphabet (A)",
"alphabet (D)",
"alphabet (G)",
"alphabet (G, R, A, N and D)",
"alphabet (N)",
"alphabet (R)",
"a pet",
"a pet border collie",
"a pet cat",
"a pet chicken",
"a pet Christmas elf",
"a pet cute hippo",
"a pet dog",
"a pet duck",
"a pet fancy bear",
"a pet food",
"a pet ghost",
"a pet golden retriever",
"a pet huggy wuggy",
"a pet husky",
"a pet kitty bunny",
"a pet lion cub",
"a pet monkey",
"a pet panda",
"a pet panther",
"a pet pig",
"a pet poodle",
"a pet pug",
"a pet puma",
"a pet pumpkin guardian",
"a pet rabbit",
"a pet rat",
"a pet resource miners ticket",
"a pet rooster",
"a pet rottweiler",
"a pet Santa Claus",
"a pet treat",
"a pet voodoo doll",
"a pet westie",
"a pet X-mas husky",
"a platinum prime ticket",
"a platinum prime ticket of type 7",
"a platinum prime ticket of type 10",
"a platinum prime ticket of type 15",
"a platinum prime ticket of type 20",
"a platinum prime ticket of type 21",
"a platinum prime ticket of type 30",
"a prime ticket",
"a prime ticket of type 3",
"a prime ticket of type 5",
"a prime ticket of type 7",
"a prime ticket of type 10",
"a prime ticket of type 15",
"a prime ticket of type 20",
"a prime ticket of type 30",
"arena container",
"a resource miners ticket",
"a starter prime ticket of type 7",
"a starter prime ticket of type 10",
"a starter prime ticket of type 15",
"a starter prime ticket of type 20",
"a starter prime ticket of type 30",
"attack juice",
"automatic drill",
"automatic oil well",
"automatic rod",
"automatic sawmill",
"automatic watering can",
"backpack space (low, medium, high & max quality)",
"baltic beer",
"battery",
"batteries",
"Benefactor container",
"big Birthday gift",
"big fireworks",
"binoculars",
"blazzzer alcohlic beverage",
"blue fabric",
"body armour skin",
"burglarized house container",
"cabbage",
"cabbage seeds",
"campfire",
"caravan container",
"carp",
"Cayo Perico tickets",
"chair",
"chair 1",
"chair 2",
"chair 3",
"chair 4",
"chair 5",
"chair 6",
"Christmas lollipop",
"Christmas tree of type 1",
"Christmas tree of type 2",
"Christmas tree of type 3",
"Christmas tree of type 4",
"Christmas tree of type 5",
"cigarettes",
"coblevo wine",
"container for bikers 1",
"container for bikers 2",
"container for bikers 3",
"container for bikers 4",
"container for bikers 5",
"container for branded shorts",
"container for branded t-shirts",
"container for drifters 1",
"container for drifters 2",
"container for drifters 3",
"container for men 1",
"container for men 2",
"container for racers 1",
"container for racers 2",
"container for racers 3",
"container for women 1",
"container for women 2",
"container with wheels 1",
"container with wheels 2",
"container with wheels 3",
"copper",
"daily container",
"desert scarf mask container",
"diamond",
"dice",
"double paycheck juice",
"drawing print",
"earplugs",
"electric chargers",
"elixir",
"emerald",
"endurance juice",
"exclusive truckers container",
"explosive fireworks",
"fast running juice",
"fish",
"flag",
"flame and water lottery ticket",
"flowers",
"fruit",
"fuel canister",
"fuel for resource extraction",
"gardeners container",
"gasoline barrels",
"grand ticket",
"GrandPro bodycam",
"green fabric",
"grill",
"high quality backpack space",
"high quality brakes",
"high quality engine",
"high quality fishing rod",
"high quality metal",
"high quality pickaxe",
"high quality suspension",
"high quality transmission",
"high quality tyres",
"hookah",
"immunity juice",
"ingrand container",
"kerosene barrels",
"leash",
"license plate",
"lottery tickets",
"love container",
"low quality backpack space",
"low quality brakes",
"low quality engine",
"low quality fishing rod",
"low quality pickaxe",
"low quality suspension",
"low quality transmission",
"low quality tyres",
"luminous stone",
"mandarin seeds",
"mandarins",
"map of Los Santos",
"max quality backpack space",
"medium quality backpack space",
"medium quality brakes",
"medium quality engine",
"medium quality fishing rod",
"medium quality pickaxe",
"medium quality suspension",
"medium quality transmission",
"medium quality tyres",
"milk",
"mining resources",
"Monowheel",
"multivitamin juice",
"mushroom seeds",
"mushrooms",
"neon armoured vest skin",
"neon armoured vest skin (V.1)",
"neon armoured vest skin (V.2)",
"neon armoured vest skin (V.3)",
"neon armoured vest skin with chains",
"neon armoured vest skin with chains (V.1)",
"neon armoured vest skin with chains (V.2)",
"neon armoured vest skin with chains (V.3)",
"neon Lui Vi armoured vest skin",
"neon Lui Vi armoured vest skin (V.1)",
"neon Lui Vi armoured vest skin (V.2)",
"neon Lui Vi armoured vest skin (V.3)",
"neon Muci armoured vest skin",
"neon Muci armoured vest skin (V.1)",
"neon Muci armoured vest skin (V.2)",
"neon Muci armoured vest skin (V.3)",
"neon Summer 2023 armoured vest skin",
"neon Summer 2023 armoured vest skin (V.1)",
"neon Summer 2023 armoured vest skin (V.2)",
"neon Summer 2023 armoured vest skin (V.3)",
"new year gift",
"Ocelot container",
"oil barrel",
"old autumn gold container",
"old summer gold container",
"old winter gold container",
"organisation container",
"paint cans",
"pearl",
"perch",
"pickaxe (low, medium & high quality)",
"pineapple seeds",
"pineapples",
"pool table",
"port wine 666",
"power armoured vest skin",
"power armoured vest skin (V.1)",
"power armoured vest skin (V.2)",
"power armoured vest skin (V.3)",
"power booster",
"power juice",
"premium fuel canister",
"prints",
"Progen container",
"protection juice",
"pumpkin seeds",
"pumpkins",
"purifield water",
"purple fabric",
"rare lottery tickets",
"red fabric",
"repair kit",
"resource scanner",
"resources container",
"riding juice",
"ruby/rubies",
"salmon",
"sand",
"sand figures",
"secret ticket fragment",
"secret ticket",
"scarecrow flag",
"school container",
"scrap metal",
"shovel",
"sim-cards",
"Single fireworks",
"small Birthday gift",
"snow",
"snowballs",
"snow figure of type 1",
"snow figure of type 1/2/3",
"snow figure of type 2",
"snow figure of type 3",
"solar barrel",
"solar panel",
"sphere of influence container",
"strawberries",
"study of the organisation container",
"Summer 2023 armoured vest skin",
"Summer 2023 armoured vest skin (V.1)",
"Summer 2023 armoured vest skin (V.2)",
"Summer 2023 armoured vest skin (V.3)",
"tactical grand armoured vest skin",
"tactical grand armoured vest skin (V.1)",
"tactical grand armoured vest skin (V.2)",
"tactical grand armoured vest skin (V.3)",
"tactical grand armoured vest skin (V.4)",
"tactical grand armoured vest skin (V.5)",
"tent",
"threads",
"timber",
"tincture of the forest mushrooms",
"tokens",
"treasure map",
"Trezor container",
"trout",
"tuning parts",
"unique love container",
"unique rims of type 1",
"unique rims of type 2",
"unique rims of type 3",
"unique rims of type 4",
"unique rims of type 5",
"unique rims of type 6",
"unique rims of type 7",
"unique rims of type 8",
"unique rims of type 9",
"unique rims of type 10",
"unique rims of type 11",
"unique rims of type 12",
"unique rims of type 13",
"unique rims of type 14",
"unique rims of type 15",
"unique rims of type 16",
"unique rims of type 17",
"unique rims of type 18",
"unique rims of type 19",
"unique rims of type 20",
"unique rims of type 21",
"unique rims of type 22",
"unique rims of type 23",
"unique rims of type 24",
"unique rims of type 25",
"unique rims of type 26",
"unique rims of type 27",
"unique rims of type 28",
"unique rims of type 29",
"unique rims of type 30",
"unique rims of type 31",
"unique rims of type 32",
"unique rims of type 33",
"unique rims of type 34",
"unique rims of type 35",
"unique rims of type 36",
"unique rims of type 37",
"unique rims of type 38",
"unique rims of type 39",
"unique rims of type 40",
"valuable container",
"Valentine gift",
"video card",
"vodka-shotka",
"volcano fireworks",
"wire",
"yellow fabric"
];

class TransactionForm {
    constructor() {
        this.state = {
            type: 'selling',
            isTrading: false,
            items: ['', '', ''],
            prices: ['', '', ''],
            usePluralS: [false, false, false],
            useRespectively: false,
            activeItemCount: 1,
            useEach: [false, false, false],
            useInBulk: false
        };

        this.initializeElements();
        this.attachEventListeners();
        this.updateUI(); // Initial UI update
        this.updatePreview(); // Initial preview update
    }

    initializeElements() {
        this.form = document.getElementById('transactionForm');
        this.itemsContainer = document.getElementById('itemsContainer');
        this.pricesContainer = document.getElementById('pricesContainer');
        this.preview = document.getElementById('preview');
        this.itemCount = document.getElementById('itemCount');
        this.itemsTitle = document.getElementById('itemsTitle');
        // MODIFIED: Select the single respectively checkbox
        this.respectivelyCheckContainer = document.querySelector('.respectively-check');
        this.respectivelyCheckInput = document.getElementById('respectively'); // Get the actual input


        this.itemControls = document.querySelector('.item-controls');
        this.inBulkInput = document.getElementById('inBulkOption'); // Updated ID
        this.inBulkLabel = document.querySelector('label[for="inBulkOption"]'); // Get the label
        this.tradingOptionInput = document.getElementById('tradingOption'); // Get Trading Option input
        this.tradingOptionLabel = document.querySelector('label[for="tradingOption"]'); // Get Trading Option label
    }

    attachEventListeners() {
        // Transaction Type Radio Buttons are handled by the inline script now.
        // Their 'change' events on the hidden inputs will be listened to update state
        document.querySelectorAll('input[name="transactionType"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                this.state.type = e.target.value;
                this.updatePreview();
            });
        });

        // Trading Option Input change listener (kept from previous versions)
        if (this.tradingOptionInput) {
            this.tradingOptionInput.addEventListener('change', (e) => {
                this.state.isTrading = e.target.checked;
                this.state.activeItemCount = e.target.checked ? 2 : 1; // Set item count to 2 for trading
                this.updateUI(); // Update UI based on trading state
                this.updatePreview(); // Update preview
            });
             // Initialize the active state of the Trading Option label on page load
            if (this.tradingOptionInput.checked && this.tradingOptionLabel) {
                 this.tradingOptionLabel.classList.add('active');
             }
        }

        // MODIFIED: Attach listener to the single respectively input
        if (this.respectivelyCheckInput) {
             this.respectivelyCheckInput.addEventListener('change', (e) => {
                 this.state.useRespectively = e.target.checked;
                  // Toggle active class on the label
                 const label = this.respectivelyCheckInput.closest('label');
                 if (label) {
                     if (e.target.checked) {
                         label.classList.add('active');
                     } else {
                         label.classList.remove('active');
                     }
                 }
                 this.updatePreview();
             });
        }


        document.getElementById('addItem').addEventListener('click', () => this.handleAddItem());
        document.getElementById('removeItem').addEventListener('click', () => this.handleRemoveItem());

        document.getElementById('items-copy-btn').addEventListener('click', () => this.handleCopy());

        // Generate Button
        document.getElementById('items-submit-btn').addEventListener('click', () => this.handleGenerate());

        // Reset Button
        const itemsResetBtn = document.getElementById('items-reset-btn');
        if (itemsResetBtn) {
            itemsResetBtn.addEventListener('click', () => this.resetForm());
        }

        // Event listener for the "In Bulk" checkbox button (handled by inline script now)
        if (this.inBulkInput && this.inBulkLabel) {
             this.inBulkInput.addEventListener('change', (e) => {
                 this.state.useInBulk = e.target.checked;
                 this.updatePreview();
                 // The inline script handles adding/removing the 'active' class on the label
             });
             // Initialize the active state of the In Bulk label on page load
             if (this.inBulkInput.checked) {
                 this.inBulkLabel.classList.add('active');
             }
         }
    }

    handleAddItem() {
        if (this.state.activeItemCount < 3 && !this.state.isTrading) { // Only add if not trading
            this.state.activeItemCount++;
             // Initialize state for the new item and price
            this.state.items[this.state.activeItemCount - 1] = '';
            this.state.prices[this.state.activeItemCount - 1] = '';
            this.state.usePluralS[this.state.activeItemCount - 1] = false;
            this.state.useEach[this.state.activeItemCount - 1] = false;

            this.updateUI();
            this.updatePreview();
        }
    }

    handleRemoveItem() {
        if (this.state.activeItemCount > 1 && !this.state.isTrading) { // Only remove if not trading
            // Clear state for the item being removed
            this.state.items[this.state.activeItemCount - 1] = '';
            this.state.prices[this.state.activeItemCount - 1] = '';
            this.state.usePluralS[this.state.activeItemCount - 1] = false;
            this.state.useEach[this.state.activeItemCount - 1] = false;

            this.state.activeItemCount--;
            this.updateUI();
            this.updatePreview();
        }
    }

     handleCopy() {
        const button = document.getElementById('items-copy-btn');
        const originalContent = button.innerHTML;
        const previewContent = this.preview.textContent;
        const placeholderText = 'Complete the form to generate your transaction description';

        // Only copy if the preview content is not the placeholder text
        if (previewContent === placeholderText) {
            // Optionally, show a message to the user that there's nothing to copy yet
            if (typeof showNotification === 'function') {
                showNotification('Please fill out the form first.');
            } else {
                console.log('Please fill out the form first.');
            }
            return; // Stop the copy process
        }


        // Create a temporary textarea element to hold the text
        const tempTextArea = document.createElement('textarea');
        tempTextArea.value = previewContent; // Use the actual preview content
        document.body.appendChild(tempTextArea);

        // Select the text in the textarea
        tempTextArea.select();
        tempTextArea.setSelectionRange(0, 99999); // For mobile devices

        // Copy the text to the clipboard
        navigator.clipboard.writeText(tempTextArea.value).then(() => {
             // Show notification (assuming you add the notification element and CSS)
             const notification = document.getElementById('notification');
             if (notification) {
                 notification.classList.add('show');
                 setTimeout(() => {
                     notification.classList.remove('show');
                 }, 2000); // Hide after 2 seconds
             }

             // Change button text and icon
             button.innerHTML = `
                 <i class="fas fa-check"></i> <span class="d-none d-sm-inline">Copied!</span>
             `;

             // Restore original button content after a delay
             setTimeout(() => {
                 button.innerHTML = originalContent;
             }, 2000); // Match notification display time

         }).catch(err => {
             console.error('Failed to copy:', err);
             // Optionally, provide feedback to the user that copying failed
         }).finally(() => {
             // Clean up the temporary textarea
             document.body.removeChild(tempTextArea);
         });
    }

    handleGenerate() {
        // Update the preview with the current form data
        this.updatePreview();
        
        // Show a brief notification that the ad was generated
        const notification = document.getElementById('notification');
        if (notification) {
            notification.innerHTML = '<i class="fas fa-magic"></i><span>Ad generated successfully!</span>';
            notification.classList.add('show');
            setTimeout(() => {
                notification.classList.remove('show');
            }, 2000);
        }
    }


    createInputGroup(type, index) {
        const div = document.createElement('div');
        div.className = `${type}-input-group mb-3`;

        if (type === 'item') {
            const row = document.createElement('div');
            row.className = 'row g-2';

            const itemCol = document.createElement('div');
            itemCol.className = 'col';

            const wrapper = document.createElement('div');
            wrapper.className = 'input-wrapper'; // This will have position: relative

            const inputGroup = document.createElement('div');
            inputGroup.className = 'input-group';

            const span = document.createElement('span');
            span.className = 'input-group-text';
            span.innerHTML = '<i class="fas fa-box"></i>'; // Using Font Awesome icon

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'form-control item-input';
            input.placeholder = this.state.isTrading
                ? (index === 0 ? 'Your item' : 'Wanted item')
                : `Item ${index + 1}`;

            // Extract item name without quantity for setting value and suggestions
            const initialItemValue = this.state.items[index]?.split(' x ')[0] || '';
            input.value = initialItemValue;


            input.addEventListener('input', (e) => {
                const quantity = this.state.items[index]?.split(' x ')[1] || '';
                this.state.items[index] = quantity ? `${e.target.value.trim()} x ${quantity.trim()}` : e.target.value.trim();
                this.handleItemInput(e.target, index);
                this.updatePreview();
            });

             // Add event listener for focus to show suggestions
             input.addEventListener('focus', (e) => {
                 // Trigger input event on focus to show suggestions if text is already there
                 if (e.target.value) {
                     this.handleItemInput(e.target, index);
                 }
             });

             // Add event listener for blur to hide suggestions (with a slight delay)
             input.addEventListener('blur', () => {
                 setTimeout(() => {
                     const suggestionsDiv = wrapper.querySelector('.suggestion-box'); // Select relative to wrapper
                     if (suggestionsDiv) {
                         suggestionsDiv.style.display = 'none';
                     }
                 }, 200); // Increased delay for better UX
             });


            inputGroup.appendChild(span);
            inputGroup.appendChild(input);
            wrapper.appendChild(inputGroup);

            const suggestions = document.createElement('div');
            suggestions.className = 'suggestion-box'; // Use consistent class
            wrapper.appendChild(suggestions);

            itemCol.appendChild(wrapper);

            const quantityCol = document.createElement('div');
            quantityCol.className = 'col-3';

            const quantityInput = document.createElement('input');
            quantityInput.type = 'text';
            quantityInput.className = 'form-control quantity-input'; // Add a class for easier selection
            quantityInput.placeholder = 'Qty'; // Shorter placeholder
            // Extract quantity for setting initial value
            const initialQuantityValue = this.state.items[index]?.split(' x ')[1] || '';
            quantityInput.value = initialQuantityValue;


            quantityInput.addEventListener('input', (e) => {
                const itemName = this.state.items[index]?.split(' x ')[0] || '';
                this.state.items[index] = e.target.value.trim() ? `${itemName.trim()} x ${e.target.value.trim()}` : itemName.trim();
                this.updatePreview();
            });

            quantityCol.appendChild(quantityInput);

            const pluralCol = document.createElement('div');
            pluralCol.className = 'col-auto d-flex align-items-center'; // Use col-auto to fit content

            const pluralCheckLabel = document.createElement('label'); // Style this label as a button
            pluralCheckLabel.className = 'checkbox-button-label';
            pluralCheckLabel.htmlFor = `usePluralS${index}`;

            const pluralInput = document.createElement('input');
            pluralInput.type = 'checkbox';
            pluralInput.id = `usePluralS${index}`;
            pluralInput.className = 'd-none'; // Hide the default checkbox
            pluralInput.checked = this.state.usePluralS[index];

            const pluralTextSpan = document.createElement('span');
            pluralTextSpan.textContent = 'Add "S"';

            pluralCheckLabel.appendChild(pluralInput);
            // The tick icon is handled by the CSS pseudo-element
            pluralCheckLabel.appendChild(pluralTextSpan);

            // *** REMOVED redundant click listener from the label ***
            // pluralCheckLabel.addEventListener('click', (e) => {
            //      e.preventDefault(); // Prevent default label click
            //      pluralInput.checked = !pluralInput.checked;
            //      pluralInput.dispatchEvent(new Event('change')); // Trigger change event
            // });

            // Keep the change listener on the hidden input
            pluralInput.addEventListener('change', (e) => {
                this.state.usePluralS[index] = e.target.checked;
                 // Get the parent label element and toggle the active class
                 const label = e.target.parentElement;
                 if (label) {
                     if (e.target.checked) {
                         label.classList.add('active');
                     } else {
                         label.classList.remove('active');
                     }
                 }
                this.updatePreview(); // Update preview when "Add S" state changes
            });

             // Initialize the active state of the plural label on creation
            if (this.state.usePluralS[index]) {
                pluralCheckLabel.classList.add('active');
            }


            pluralCol.appendChild(pluralCheckLabel);

            row.appendChild(itemCol);
            row.appendChild(quantityCol);
            // Only add plural column if not trading
            if (!this.state.isTrading) {
                 row.appendChild(pluralCol);
            }
            div.appendChild(row);

        } else { // Type is 'price'
            const row = document.createElement('div');
            row.className = 'row g-2';

            const priceCol = document.createElement('div');
            priceCol.className = 'col';

            const inputGroup = document.createElement('div');
            inputGroup.className = 'input-group';

            const span = document.createElement('span');
            span.className = 'input-group-text';
            span.innerHTML = '<i class="fas fa-dollar-sign"></i>'; // Using Font Awesome icon

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'form-control price-input'; // Add a class for potential price input specific styling
            input.placeholder = this.state.isTrading ? `Price/Budget for item ${index + 1}` : `Price for item ${index + 1}`; // Adjust placeholder for trading
            input.value = this.state.prices[index];


            input.addEventListener('input', (e) => {
                this.state.prices[index] = e.target.value.trim(); // Trim price input
                this.updatePreview();
            });

            inputGroup.appendChild(span);
            inputGroup.appendChild(input);
            priceCol.appendChild(inputGroup);

            const eachCol = document.createElement('div');
            eachCol.className = 'col-auto d-flex align-items-center';

            const eachCheckLabel = document.createElement('label'); // Style this label as a button
            eachCheckLabel.className = 'checkbox-button-label';
            eachCheckLabel.htmlFor = `useEach${index}`;

            const eachInput = document.createElement('input');
            eachInput.type = 'checkbox';
            eachInput.id = `useEach${index}`;
            eachInput.className = 'd-none'; // Hide the default checkbox
            eachInput.checked = this.state.useEach[index];

            const eachTextSpan = document.createElement('span');
            eachTextSpan.textContent = 'Each';

            eachCheckLabel.appendChild(eachInput);
             // The tick icon is handled by the CSS pseudo-element
            eachCheckLabel.appendChild(eachTextSpan);

            // *** REMOVED redundant click listener from the label ***
            // eachCheckLabel.addEventListener('click', (e) => {
            //      e.preventDefault(); // Prevent default label click
            //      eachInput.checked = !eachInput.checked;
            //      eachInput.dispatchEvent(new Event('change')); // Trigger change event
            // });

             // Keep the change listener on the hidden input
            eachInput.addEventListener('change', (e) => {
                this.state.useEach[index] = e.target.checked;
                 // Get the parent label element and toggle the active class
                const label = e.target.parentElement;
                 if (label) {
                     if (e.target.checked) {
                         label.classList.add('active');
                     } else {
                         label.classList.remove('active');
                     }
                 }
                this.updatePreview(); // Update preview when "Each" state changes
            });

             // Initialize the active state of the each label on creation
             if (this.state.useEach[index]) {
                 eachCheckLabel.classList.add('active');
             }


            eachCol.appendChild(eachCheckLabel);

            row.appendChild(priceCol);
            // Only add 'Each' column if not trading
            if (!this.state.isTrading) {
                 row.appendChild(eachCol);
            }
            div.appendChild(row);
        }

        return div;
    }

    handleItemInput(input, index) {
        // Select suggestions div relative to the parent wrapper
        const suggestionsDiv = input.closest('.input-wrapper').querySelector('.suggestion-box');
        const value = input.value.toLowerCase();

        // Clear previous suggestions if input is empty
        if (!value) {
            if (suggestionsDiv) {
                 suggestionsDiv.innerHTML = '';
                 suggestionsDiv.style.display = 'none';
             }
             return; // Exit if no input value
        }


        if (suggestionsDiv) { // Check if suggestionsDiv was found
            const filtered = backpackSkins.filter(skin =>
                skin.toLowerCase().includes(value)
            );

            if (filtered.length > 0) {
                suggestionsDiv.innerHTML = filtered.map(suggestion => `
                    <div class="suggestion-item">${suggestion}</div>
                `).join('');

                suggestionsDiv.style.display = 'block';

                suggestionsDiv.querySelectorAll('.suggestion-item').forEach(item => {
                    // Use a mousedown listener instead of click for suggestions
                    // This fires before the blur event on the input, allowing the click to register
                    item.addEventListener('mousedown', (e) => {
                         e.preventDefault(); // Prevent input blur from hiding suggestions immediately
                         const selectedValue = item.textContent;
                         const quantity = this.state.items[index]?.split(' x ')[1] || '';
                         this.state.items[index] = quantity ? `${selectedValue.trim()} x ${quantity.trim()}` : selectedValue.trim(); // Trim selected value
                         input.value = selectedValue; // Set input value to selected suggestion
                         if (suggestionsDiv) {
                            suggestionsDiv.innerHTML = '';
                            suggestionsDiv.style.display = 'none';
                         }
                         this.updatePreview(); // Update preview after selecting suggestion
                    });
                });
            } else {
                suggestionsDiv.style.display = 'none';
            }
        }
    }

    updateUI() {
        this.itemsTitle.textContent = this.state.isTrading ? 'Trading Items' : 'Items';
        // Adjust item controls visibility based on trading option
        this.itemControls.style.display = this.state.isTrading ? 'none' : 'flex';


        this.itemCount.textContent = `${this.state.activeItemCount} of ${this.state.isTrading ? 2 : 3}`; // Adjust item count display for trading

        this.itemsContainer.innerHTML = '';
        this.pricesContainer.innerHTML = '';

        const count = this.state.isTrading ? 2 : this.state.activeItemCount;
        for (let i = 0; i < count; i++) {
            this.itemsContainer.appendChild(this.createInputGroup('item', i));
            this.pricesContainer.appendChild(this.createInputGroup('price', i));
        }

        // Show/hide the respectively checkbox container based on active item count and trading status
        if (this.respectivelyCheckContainer) {
             this.respectivelyCheckContainer.classList.toggle('d-none', this.state.activeItemCount <= 1 || this.state.isTrading);

             // If the respectively container is hidden, ensure the state is false
             if (this.respectivelyCheckContainer.classList.contains('d-none')) {
                  this.state.useRespectively = false;
                  if (this.respectivelyCheckInput) {
                      this.respectivelyCheckInput.checked = false;
                       // Also remove active class from label if it exists
                       const label = this.respectivelyCheckInput.closest('label');
                       if (label) label.classList.remove('active');
                  }
             }
             // Auto-activate respectively when there are 2 or more items and not trading
             else if (this.state.activeItemCount >= 2 && !this.state.isTrading && this.respectivelyCheckInput) {
                  this.state.useRespectively = true;
                  this.respectivelyCheckInput.checked = true;
                  const label = this.respectivelyCheckInput.closest('label');
                  if (label) label.classList.add('active');
             }
        }


        document.getElementById('addItem').disabled = this.state.activeItemCount >= 3 || this.state.isTrading;
        document.getElementById('removeItem').disabled = this.state.activeItemCount <= 1 || this.state.isTrading;

         // Hide the In Bulk option if trading is selected
        if (this.inBulkLabel) { // Check if the element exists
            this.inBulkLabel.style.display = this.state.isTrading ? 'none' : 'inline-flex';
             // If trading is selected, ensure inBulk state is false
             if (this.state.isTrading) {
                  this.state.useInBulk = false;
                  if (this.inBulkInput) {
                      this.inBulkInput.checked = false;
                       // Manually remove active class as the change listener might not fire if already false
                      this.inBulkLabel.classList.remove('active');
                  }
             }
        }


         // Hide the "Each" checkbox for prices if trading is selected
         // Need to re-select price inputs after updating the UI
          // Since elements are recreated, re-initializing state and active classes in createInputGroup is crucial
         document.querySelectorAll('.price-input-group .checkbox-button-label').forEach(label => {
             label.style.display = this.state.isTrading ? 'none' : 'inline-flex';
         });
         // If trading is selected, ensure useEach states are false
          if (this.state.isTrading) {
              this.state.useEach = [false, false, false];
              // No need to manually remove active classes here as updateUI recreates elements
          }

    }

    formatPrice(price) {
        if (!price) return 'Negotiable'; // Return "Negotiable" if price is empty

        let cleanPrice = price.toString().toLowerCase().replace(/[^0-9km.]/g, '');
        let numericValue;

        if (cleanPrice.includes('k')) {
            numericValue = parseFloat(cleanPrice.replace('k', '')) * 1000;
            if (!isNaN(numericValue)) {
                // Replace commas with periods in the formatted output
                return numericValue.toLocaleString('en-US', { minimumFractionDigits: 0 }).replace(/,/g, '.');
            }
        } else if (cleanPrice.includes('m')) {
            numericValue = parseFloat(cleanPrice.replace('m', '')) * 1000000;
            if (!isNaN(numericValue)) {
                 // Format millions: no decimal if whole number, one decimal otherwise
                const formattedNum = numericValue / 1000000;
                return `${formattedNum % 1 === 0 ? formattedNum.toFixed(0) : formattedNum.toFixed(1)} Million`;
            }
        } else {
            numericValue = parseFloat(cleanPrice);
            if (!isNaN(numericValue)) {
                // Replace commas with periods in the formatted output
                return numericValue.toLocaleString('en-US', { minimumFractionDigits: 0 }).replace(/,/g, '.');
            }
        }

        return 'Negotiable'; // Return "Negotiable" for invalid input
    }

    formatTransaction() {
        const { type, items, prices, useRespectively, activeItemCount, isTrading, useEach, usePluralS, useInBulk } = this.state;

        const validItems = items.slice(0, isTrading ? 2 : activeItemCount).filter(item => item.trim());
        // If trading and less than 2 valid items, or not trading and no valid items, return placeholder
        if ((isTrading && validItems.length !== 2) || (!isTrading && validItems.length === 0)) {
            return 'Complete the form to generate your transaction description';
        }


        const capitalizedType = type.charAt(0).toUpperCase() + type.slice(1);
        let output = `${capitalizedType}${isTrading ? ' or trading' : ''}`;

        const formattedItems = validItems.map((item, index) => {
            const [itemName, quantity] = item.split(' x ');

            const itemBaseName = itemName?.trim() || '';
            const itemQuantity = quantity?.trim();

            let formattedItemBase = itemBaseName;
             // Apply plural 's' if 'Add S' is checked AND the item name doesn't already end in 's'
             // MODIFIED CONDITION: Removed !itemQuantity && - This was done in a previous step.
              if (this.state.usePluralS[index] && !itemBaseName.endsWith('s')) {
                   formattedItemBase += 's';
              }

             // Add "a" article only for items that are defined with "a" in the backpackSkins array
             if (!isTrading && !itemQuantity && !this.state.usePluralS[index]) {
                 // Check if this exact item exists in backpackSkins with "a " prefix
                 const itemWithA = `a ${formattedItemBase}`;
                 if (backpackSkins.includes(itemWithA)) {
                     return itemWithA;
                 }
             }

             return itemQuantity && !isTrading ? `${itemQuantity} ${formattedItemBase}` : formattedItemBase; // Include quantity only if not trading
        });

         // Join items with proper formatting: comma for multiple items, "and" before the last item
         if (formattedItems.length === 1) {
             output += ` ${formattedItems[0]}`;
         } else if (formattedItems.length === 2) {
             output += ` ${formattedItems.join(' and ')}`;
         } else {
             // For 3 or more items: join all but last with commas, then "and" before the last
             const allButLast = formattedItems.slice(0, -1).join(', ');
             const lastItem = formattedItems[formattedItems.length - 1];
             output += ` ${allButLast} and ${lastItem}`;
         }


        if (useInBulk && !isTrading) { // Only add in bulk if not trading
             output += ' in bulk';
        }


        const validPrices = prices
            .slice(0, isTrading ? 2 : activeItemCount) // Consider trading state for price count
            .map(price => price.trim())
            .filter(price => price);

        let priceSection = `. ${type === 'buying' ? 'Budget' : 'Price'}: `;
        let addFinalPeriod = false; // Flag to control final period addition

        if (validPrices.length > 0) {
            const priceTexts = validPrices.map((price, index) => {
                const formattedPrice = this.formatPrice(price); // Returns "4.000" or "4 Million" or "Negotiable"
                const suffix = useEach[index] && !isTrading ? ' each' : ''; // Only add 'each' if not trading

                 // Determine if a period should be added based on *this* price text and suffix
                 // UPDATED: Add period if it's Million, Negotiable, or includes ' each'
                 if (formattedPrice.includes('Million') || formattedPrice === 'Negotiable' || suffix === ' each') {
                      addFinalPeriod = true; // Set flag if any price requires a period
                 }
                 return formattedPrice + suffix;
            });

             if (priceTexts.length === 1) {
                 priceSection += priceTexts[0] !== 'Negotiable' ? `$${priceTexts[0]}` : priceTexts[0]; // Add $ if not Negotiable
             } else if (isTrading && priceTexts.length === 2) {
                 // Trading prices: "$X and $Y"
                 // Check if price is not Negotiable before adding dollar sign
                 const price1 = priceTexts[0] !== 'Negotiable' ? `$${priceTexts[0]}` : priceTexts[0];
                 const price2 = priceTexts[1] !== 'Negotiable' ? `$${priceTexts[1]}` : priceTexts[1];
                 priceSection += `${price1} and ${price2}`;
                  // For trading, if either price requires a period, the whole section gets one
                 if (priceTexts[0].includes('Million') || priceTexts[0] === 'Negotiable' || priceTexts[0].endsWith(' each') ||
                     priceTexts[1].includes('Million') || priceTexts[1] === 'Negotiable' || priceTexts[1].endsWith(' each')) { // Check for ' each' here too
                      addFinalPeriod = true;
                 }


             }
            else if (useRespectively && validPrices.length === validItems.length && !isTrading) { // Check item count matches price count for 'respectively'
                const formattedPriceStrings = priceTexts.map(p => p !== 'Negotiable' ? `$${p}` : p); // Add $ if not Negotiable

                 if (formattedPriceStrings.length === 2) {
                      // MODIFIED: Join two prices with " and " when respectively is used
                      priceSection += formattedPriceStrings.join(' and ') + ' respectively';
                 } else {
                     // Join with ", " and final " and " for more than two prices
                     const allButLast = formattedPriceStrings.slice(0, -1).join(', ');
                     const lastPrice = formattedPriceStrings[formattedPriceStrings.length - 1];
                     priceSection += `${allButLast} and ${lastPrice} respectively`;
                 }
                addFinalPeriod = true; // 'respectively' always gets a period
            } else {
                 // For multiple non-trading prices, check if any individual price requires a period
                 priceSection += priceTexts.map(p => p !== 'Negotiable' ? `$${p}` : p).join(', '); // Add $ if not Negotiable
                  if (priceTexts.some(p => p.includes('Million') || p === 'Negotiable' || p.endsWith(' each'))) { // Check for ' each' here too
                      addFinalPeriod = true;
                  }
            }

            output += priceSection;

            // Add a final period if the flag was set and there isn't already one
             if (addFinalPeriod && !output.trim().endsWith('.')) {
                 output += '.';
            }


        } else {
            output += `. ${type === 'buying' ? 'Budget' : 'Price'}: Negotiable.`; // Period is already here for Negotiable
             addFinalPeriod = true; // Ensure flag is true for Negotiable
        }

            // --- IMPROVED: Ensure output always ends with a period for all cases except raw numbers ---
            // (e.g., "Price: $4.000" should not have a period, but "Price: Negotiable" and "Price: $4 Million" should)
            function ensureFinalPeriod(text) {
                if (text.trim().endsWith('.')) return text.trim();
                if (/\d$/.test(text.trim()) && !text.includes('Million') && !text.includes('Negotiable') && !text.endsWith(' each') && !text.endsWith('respectively')) return text.trim();
                return text.trim() + '.';
            }
            return ensureFinalPeriod(output.trim());
    }


    updatePreview() {
        const output = this.formatTransaction();
        this.preview.textContent = output || 'Complete the form to generate your transaction description';
    }

    resetForm() {
        // Reset state
        this.state = {
            type: 'selling',
            isTrading: false,
            items: ['', '', ''],
            prices: ['', '', ''],
            usePluralS: [false, false, false],
            useEach: [false, false, false],
            activeItemCount: 1,
            useInBulk: false,
            useRespectively: false
        };

        // Reset transaction type radio buttons
        const sellingRadio = document.querySelector('input[name="transactionType"][value="selling"]');
        if (sellingRadio) {
            sellingRadio.checked = true;
        }

        // Reset trading checkbox
        if (this.tradingOptionInput) {
            this.tradingOptionInput.checked = false;
            if (this.tradingOptionLabel) {
                this.tradingOptionLabel.classList.remove('active');
            }
        }

        // Reset in bulk checkbox
        if (this.inBulkInput) {
            this.inBulkInput.checked = false;
            if (this.inBulkLabel) {
                this.inBulkLabel.classList.remove('active');
            }
        }

        // Reset respectively checkbox
        if (this.respectivelyCheckInput) {
            this.respectivelyCheckInput.checked = false;
            const label = this.respectivelyCheckInput.closest('label');
            if (label) {
                label.classList.remove('active');
            }
        }

        // Update UI and preview
        this.updateUI();
        this.updatePreview();
    }
}

document.addEventListener('DOMContentLoaded', () => {
    new TransactionForm();

    // Hide suggestions when clicking outside of any input-group
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.input-group')) {
            document.querySelectorAll('.suggestions').forEach(s => {
                s.classList.add('d-none');
            });
        }
    });
});
}